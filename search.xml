<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift 粒子动画CAEmitterLayer简单使用]]></title>
    <url>%2F2019%2F04%2F22%2FiOS%2FCoreAnimation%2FCAEmitter%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[粒子系统介绍 什么是粒子系统？ 粒子系统是由总体具有相同的表现规律，个体却随机表现出不同的特征的大量显示元素构成的集合。 粒子定义有三要素 群体性：粒子系统是由“大量显示元素”构成的(例如雪、雨、一团雾等等) 统一性：粒子系统的每个元素具有相同的表现规律(例如下雨、下雪，方向都是从上向下) 随机性：粒子系统的每个元素又随机表现出不同特征(例如下雪，每个雪花下落的速度会有不同，大小会有不同、方向也会有略微的不同) 粒子系统应用场景 影视行业 目前我们经常看的大片，比如沙尘暴、暴风雨、暴雪、烟花 等等，很多都是粒子特效做出来的。很逼真，而且相比真实世界中去实拍，成本要低很多 游戏中 爆炸、雨、雪、雾、烟花等等。都是粒子系统实现 应用中 主播房间右下角粒子动画 雪花/下雨/烟花等效果 QQ生日快乐一堆表情的跳动 粒子系统的使用 步骤 创建发射器 创建粒子, 设置粒子属性 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859protocol Emitterable &#123; &#125;extension Emitterable where Self : UIViewController &#123; func startEmittering(_ point : CGPoint) &#123; // 1.创建发射器 let emitter = CAEmitterLayer() // 2.设置发射器的位置 emitter.emitterPosition = point // 3.开启三维效果 emitter.preservesDepth = true // 4.创建粒子, 并且设置例子相关的属性 let cell = CAEmitterCell() // 4.2.设置粒子速度 cell.velocity = 150 cell.velocityRange = 100 // 4.3.设置例子的大小 cell.scale = 0.7 cell.scaleRange = 0.3 // 4.4.设置粒子方向 cell.emissionLongitude = CGFloat.pi / 2 cell.emissionRange = CGFloat.pi / 6 // 4.5.设置例子的存活时间 cell.lifetime = 3 cell.lifetimeRange = 1.5 // 4.6.设置粒子旋转 cell.spin = CGFloat.pi / 2 cell.spinRange = CGFloat.pi / 4 // 4.6.设置例子每秒弹出的个数 cell.birthRate = 2 // 4.7.设置粒子展示的图片 cell.contents = UIImage(named: "imageName")?.cgImage // 5.将粒子设置到发射器中 emitter.emitterCells = [cell] // 6.将发射器的layer添加到父layer中 view.layer.addSublayer(emitter) &#125; /// 移除CAEmitterLayer func stopEmittering() &#123; view.layer.sublayers?.filter(&#123; $0.isKind(of: CAEmitterLayer.self)&#125;).first?.removeFromSuperlayer() &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>粒子动画</tag>
        <tag>CAEmitterLayer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS全屏手势POP]]></title>
    <url>%2F2019%2F04%2F21%2FfullScreenPop.html</url>
    <content type="text"><![CDATA[开篇在iOS中,默认如果有导航控制器,当push到下一个控制器时,当前界面时可以局部侧滑返回的,这一段范围很少. 既然系统已经给我们了实现好了,侧滑返回,那么我们如何解决,全屏手势侧滑返回呢? 方案拿到系统的返回手势,操作一波runtime 打印导航控制器所有私有属性123456789/// 通过runtime获取对应的手势属性var count : UInt32 = 0let ivars = class_copyIvarList(UIGestureRecognizer.self, &amp;count)!for i in 0..&lt;count &#123; let ivar = ivars[Int(i)] let namep = ivar_getName(ivar) let name = String(cString: namep!)//属性名称 print(name)&#125; 打印结果: 1234567891011121314151617181920212223242526_gestureFlags_targets // 这个保存手势的所有target_delayedTouches_delayedPresses_view_lastTouchTimestamp_firstEventTimestamp_state_allowedTouchTypes_initialTouchType_internalActiveTouches_forceClassifier_requiredPreviewForceState_touchForceObservable_touchForceObservableAndClassifierObservation_forceTargets_forcePressCount_beganObservable_failureRequirements_failureDependents_activeEvents_keepTouchesOnContinuation_delegate_allowedPressTypes_name_gestureEnvironment 获取target123456guard let anyObject = interactivePopGestureRecognizer!.value(forKey: "_targets") as? [AnyObject] else &#123; return &#125;let object = anyObject.firstprint(object) 打印结果: 12/// 原来是一个数组,数组中是一个tuple, tuple第一个是一个action,第二个既然是target对象[(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x7fc664e4f850&gt;)] KVC 取出target12345let target = object.value(forKeyPath: "target")let action = Selector(("handleNavigationTransition:"))//下面是获取不到action的会奔溃//let action = object.value(forKeyPath: "action") as? Selector 替换手势123//创建自己的手势 将系统的手势去代替自己创建的手势let panGes = UIPanGestureRecognizer(target: target, action: action)view.addGestureRecognizer(panGes) 使用FDFullscreenPopGesture这玩意就补多少了,添加进去,啥都不用干,懒人方案,完美解决。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Pop</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 上配置 aria2 加快下载速度的方法]]></title>
    <url>%2F2019%2F04%2F18%2Faria2_config.html</url>
    <content type="text"><![CDATA[作为mac 用户,受够了各种下载限速，浏览器自带的下载器极为蛋疼，不如花点时间来配置 aria2，结合 Chrome 插件配置之后,真香! aria2 是什么？aria2 是一款支持多种协议的轻量级命令行下载工具。有以下特性： 多线程连线：aria2 会自动从多个线程下载文件，并充分利用你的带宽。 轻量：运行时不会占用过多资源，根据官方介绍，内存占用通常在 4MB~9MB ，使用 BitTorrent 协议，下行速度 2.8MB/s 时 CPU 占用率约 6% 。 全功能 BitTorrent 客户端。 支持 RPC 界面远程控制。 安装 Homebrew由于是使用 Homebrew 方式安装，所以需要先安装 Homebrew ，已经装过了可以跳过这一步，终端输入以下命令安装。 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装 aria2在终端输入以下命令安装。1brew install aria2 设置配置文件aria2 提供两种方式使用，一种是直接命令行模式下载，不推荐使用这种方法，推荐使用另外一种 RPC 模式，这种方式 aria2 启动之后只会安静的等待下载请求，下载完成后也只会安静的驻留后台不会自动退出。而使用 RPC 模式推荐做一个配置文件方便使用。 我们把配置文件放在 ~/.aria2 下，终端依次输入以下命令： 1234cd ~mkdir .aria2cd .aria2touch aria2.conf 接着打开 Finder，利用 shift + command + G 进入路径：~/.aria2/aria2.conf，用文本编辑器打开 aria2.conf，将 雪月秋水君 提供的以下配置直接拷贝进去： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#用户名#rpc-user=user#密码#rpc-passwd=passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret=token#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许外部访问，false的话只监听本地端口rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=5#断点续传continue=true#同服务器连接数max-connection-per-server=5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#文件保存路径, 默认为当前启动位置dir=/Users/xxx/Downloads#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation=prealloc 默认下载路径的 /Users/xxx/Downloads 可以改为任何你想要的绝对路径。此处写为 Downloads 目录，xxx 请自行替换成你的 mac 用户名，然后保存，退出编辑器。 启动 RPC 模式在终端输入以下命令启动 RPC 模式，将 xxx 替换成你的 mac 用户名。 1aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -D 开始使用下载 chrome 浏览器下载插件：Camtd - Aria2下载管理器, 下载完成后右键下载链接点击 Send to Aria2 即可下载，也支持拦截下载。 这个插件不满意的话，也可以搜索其他类似插件，但必须启动 RPC 模式才能够使用此类插件。 文章参考 Mac 上使用百度网盘很烦躁？花点时间配置 aria2 吧 。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>aria2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Moya&Alamofire&RxSwift&ObjectMapper的配合使用]]></title>
    <url>%2F2018%2F04%2F13%2FiOS%2FSwift%2FSwift-Moya%26Alamofire%26RxSwift%26ObjectMapper%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[Moya&amp;Alamofire&amp;RxSwift&amp;ObjectMapper的配合使用主要是学习Moya的熟练使用，全文涉及到CYLTabBarController搭建简单易用的框架、Swift和OC互相调用、FLEX显示界面层级UI的属性、ObjectMapper解析数据、Kingfisher加载网络图片、MBProgressHUD融合到请求里自动显示与隐藏请求等待、MJRefresh作为刷新简单写了一个类别、SDCycleScrollView显示轮播图、Then的使用,最终实现了一个简单的界面.. 既然是介绍Moya的就主要先来介绍它吧，Moya是对 Alamofire的进一步封装,简化了网络请求,方便维护 点击查看官方教程 Moya发送简单的网络请求###枚举类型需满足TargetType协议 1234567public protocol TargetType &#123; var baseURL: NSURL &#123; get &#125; var path: String &#123; get &#125; var method: Moya.Method &#123; get &#125; var parameters: [String: AnyObject]? &#123; get &#125; var sampleData: NSData &#123; get &#125;&#125; 实现一个枚举代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import Foundationimport Moyaenum ApiManager &#123; case getDantangList(String) case getNewsList case getMoreNews(String) case getThemeList case getThemeDesc(Int) case getNewsDesc(Int) case Create(title: String, body: String, userId: Int) case Login(phone:String,password:String) case Banner(String)&#125;extension ApiManager: TargetType &#123; /// The target's base `URL`. var baseURL: URL &#123; switch self &#123; case .Create(_,_,_): return URL.init(string: "http://jsonplaceholder.typicode.com/")! case .getDantangList,.Banner: return URL.init(string: "http://api.dantangapp.com/")! case .Login: return URL.init(string: "https://api.grtstar.cn")! default: return URL.init(string: "http://news-at.zhihu.com/api/")! &#125;&#125;/// The path to be appended to `baseURL` to form the full `URL`. var path: String &#123; switch self &#123; case .getDantangList(let page): return "v1/channels/\(page)/items" case .getNewsList: return "4/news/latest" case .getMoreNews(let date): return "4/news/before/" + date case .getThemeList: return "4/themes" case .getThemeDesc(let id): return "4/theme/\(id)" case .getNewsDesc(let id): return "4/news/\(id)" case .Create(_, _, _): return "posts" case .Login: return "/rest/user/certificate" case .Banner: return "v1/banners" &#125; /// The HTTP method used in the request. var method: Moya.Method &#123; switch self &#123; case .Create(_, _, _): return .post case .Login: return .post default: return .get &#125; &#125; /// The parameters to be incoded in the request. var parameters: [String: Any]? &#123; switch self &#123; case .Create(let title, let body, let userId): return ["title": title, "body": body, "userId": userId] case .Login(let number, let passwords): return ["mobile" : number, "password" : passwords,"deviceId": "12121312323"] case .Banner(let strin): return ["channel" :strin] default: return nil &#125; &#125; /// The method used for parameter encoding. var parameterEncoding: ParameterEncoding &#123; return URLEncoding.default &#125; /// Provides stub data for use in testing. var sampleData: Data &#123; switch self &#123; case .Create(_, _, _): return "Create post successfully".data(using: String.Encoding.utf8)! default: return "".data(using: String.Encoding.utf8)! &#125; &#125; var task: Task &#123; return .request &#125; /// Whether or not to perform Alamofire validation. Defaults to `false`. var validate: Bool &#123; return false &#125; &#125; `&lt;/pre&gt; #### 现在就可以发送简单的网络请求了: 1.定义一个全局变量MoyaProvider &lt;pre&gt;`let ApiManagerProvider = MoyaProvider&amp;lt;ApiManager&amp;gt; `&lt;/pre&gt; 2.发送网络请求 &lt;pre&gt;`ApiManagerProvider.request(.getNewsList) &#123; (result) -&amp;gt; () in case let .success(response): break case let .failure(error): break &#125; `&lt;/pre&gt; #### MoyaProvider的初始化 我们观察下MoyaProvider的初始化方法. MoyaProvider初始化都是有默认值的 &lt;pre&gt;`public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping, requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping, stubClosure: @escaping StubClosure = MoyaProvider.neverStub, manager: Manager = MoyaProvider&amp;lt;Target&amp;gt;.defaultAlamofireManager(), plugins: [PluginType] = [], trackInflights: Bool = false) `&lt;/pre&gt; 这些可选参数就是Moya的强大之处了 ，文章主要也是介绍如何使用这些插件的。 #### 参数说明： EndpointClosure可以对请求参数做进一步的修改,如可以修改endpointByAddingParameters endpointByAddingHTTPHeaderFields等 RequestClosure 你可以在发送请求前，做点手脚. 如修改超时时间，打印一些数据等等 StubClosure可以设置请求的延迟时间,可以当做模拟慢速网络 Manager 请求网络请求的方式。默认是Alamofire [PluginType]一些插件。回调的位置在发送请求后，接受服务器返回之前 稍后详细介绍这部分内容。 RxSwiftMoya也有自己的RxSwift的扩展，不懂RxSwift的童鞋可以看下我们博客中的关于RxSwift库介绍的文章。Moya使用RxSwift很简单，如下所示我们只需要对请求结果进行监听就行了 使用RxSwift可以这样来请求 `let provider = RxMoyaProvider&lt;ApiManager&gt;()//要使用RxMoyaProvider创建provider，暂时不携带任何参数 provider.request(.getNewsList).subscribe { event in switch event { case .next(let response): // do something with the data case .error(let error): // handle the error } } ` 我们还可以对Observable进行扩展，自定义一些自己流水线操作，比如自动实现json转化Model，定义如下。 `func mapObject&lt;T: Mappable&gt;(type: T.Type) -&gt; Observable&lt;T&gt; { return self.map { response in //if response is a dictionary, then use ObjectMapper to map the dictionary //if not throw an error guard let dict = response as? [String: Any] else { throw RxSwiftMoyaError.ParseJSONError } guard (dict["code"] as?Int) != nil else{ throw RxSwiftMoyaError.ParseJSONError } if let error = self.parseError(response: dict) { throw error } return Mapper&lt;T&gt;().map(JSON: dict)! } } ` 下边的方法就需要根据服务器返回数据进行判断了，我常用的逻辑是数据请求成功了才返回再就行界面赋值刷新操作，如果是状态码不成功就直接拦截抛出错误（后台返回的message），比如是登录密码错误提示之类的 `fileprivate func parseError(response: [String: Any]?) -&gt; NSError? { var error: NSError? if let value = response { var code:Int? //后台的数据每次会返回code只有是200才会表示逻辑正常执行 if let codes = value["code"] as?Int { code = codes } if code != 200 { var msg = "" if let message = value["message"] as? String { msg = message } error = NSError(domain: "Network", code: code!, userInfo: [NSLocalizedDescriptionKey: msg]) } } return error } ` 那么就可以定义一个请求方法了 `func login(phone: String, password:String) -&gt; Observable&lt;UserModel&gt; { return provider.request(.Login(phone: phone, password: password)) .mapJSON() .debug() // 打印请求发送中的调试信息 .mapObject(type: UserModel.self) } ` 如下代码就完成了一次请求 `let viewModel = ViewModel(self) viewModel.login(phone: "156178...." , password: "11111") .subscribe(onNext: { (userModel: UserModel) in //do something with posts print(userModel.user?.nickName ?? "") }) .addDisposableTo(dispose) ` Moya也为我们提供了很多Observable的扩展，让我们能更轻松的处理MoyaResponse，常用的如下： filter(statusCodes:) 过滤response状态码 filterSuccessfulStatusCodes() 过滤状态码为请求成功的 mapJSON() 将请求response转化为JSON格式 mapString() 将请求response转化为String格式 具体可以参考官方文档 下边就说说RxMoyaProvider参数吧 EndpointClosure没写什么就打印下参数，请求方法，路径..可以核对 `private func endpointMapping&lt;Target: TargetType&gt;(target: Target) -&gt; Endpoint&lt;Target&gt; { print("请求连接：\(target.baseURL)\(target.path) \n方法：\(target.method)\n参数：\(String(describing: target.parameters)) ") return MoyaProvider.defaultEndpointMapping(for: target) } ` manager用的是Alamofire请求，这里主要写了一个忽略SSL验证的方法，当然也可以在这里修改请求头等等 `public func defaultAlamofireManager() -&gt; Manager { let configuration = URLSessionConfiguration.default configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders let policies: [String: ServerTrustPolicy] = [ "ap.dimain.cn": .disableEvaluation ] let manager = Alamofire.SessionManager(configuration: configuration,serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies)) manager.startRequestsImmediately = false return manager } ` 最有意思的还是插件了 ，可以自定义各种功能 pluginsplugins参数是一个数组的形式，遵循PluginType协议我们先看下PluginType的协议内容 `public protocol PluginType { /// Called to modify a request before sending //请求前可以修改一些request func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest /// Called immediately before a request is sent over the network (or stubbed). //开始请求 func willSend(_ request: RequestType, target: TargetType) /// Called after a response has been received, but before the MoyaProvider has invoked its completion handler. //结束请求 func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) /// Called to modify a result before completion func process(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) -&gt; Result&lt;Moya.Response, MoyaError&gt; } ` 状态条中的网络加载提示,俗称”菊花加载 networkActivityPlugin`let networkActivityPlugin = NetworkActivityPlugin { (change) -&gt; () in switch(change){ case .ended: UIApplication.shared.isNetworkActivityIndicatorVisible = false case .began: UIApplication.shared.isNetworkActivityIndicatorVisible = true } } ` NetworkActivityPlugin是Moya提供的方法，还是根据PluginType的协议实现的 请求一般就需要loading了这里用MBProgressHUD实现自动显示隐藏 ` public final class RequestLoadingPlugin: PluginType { private let viewController: UIViewController var HUD:MBProgressHUD var hide:Bool init(_ vc: UIViewController,_ hideView:Bool) { self.viewController = vc self.hide = hideView HUD = MBProgressHUD.init() guard self.hide else { return } HUD = MBProgressHUD.showAdded(to: self.viewController.view, animated: true) } public func willSend(_ request: RequestType, target: TargetType) { print("开始请求\(self.viewController)") if self.hide != false { HUD.mode = MBProgressHUDMode.indeterminate HUD.label.text = "加载中" HUD.bezelView.color = UIColor.lightGray HUD.removeFromSuperViewOnHide = true HUD.backgroundView.style = .solidColor //或SolidColor } } public func didReceive(_ result: Result&lt;Response, MoyaError&gt;, target: TargetType) { print("结束请求") HUD.hide(animated: true) } } ` 修改请求头想想不该放在插件了实现，应该是在manager里实现，先放出来代码吧 `struct AuthPlugin: PluginType { let token: String func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest { var request = request request.timeoutInterval = 30 request.addValue(token, forHTTPHeaderField: "token") request.addValue("ios", forHTTPHeaderField: "platform") request.addValue("version", forHTTPHeaderField: Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as! String) return request } } ` 请求时候遇到逻辑错误或者不满足条件，参数错误等要提示这里用的是Toast `//检测token有效性 final class AccessTokenPlugin: PluginType { private let viewController: UIViewController init(_ vc: UIViewController) { self.viewController = vc } public func willSend(_ request: RequestType, target: TargetType) {} public func didReceive(_ result: Result&lt;Response, MoyaError&gt;, target: TargetType) { switch result { case .success(let response): //请求状态码 guard response.statusCode == 200 else { return } var json:Dictionary? = try! JSONSerialization.jsonObject(with: response.data,options:.allowFragments) as! [String: Any] print("请求状态码\(json?["status"] ?? "")") guard (json?["message"]) != nil else { return } guard let codeString = json?["status"]else {return} //请求状态为1时候立即返回不弹出任何提示 否则提示后台返回的错误信息 guard codeString as! Int != 1 else{return} self.viewController.view .makeToast( json?["message"] as! String) case .failure(let error): print("出错了\(error)") break } } } ` AccessTokenPlugin这个名字有点问题哈，起初是想在这里判断token不正确就退出登录用的由于没有合适的api就实现了请求结果的状态判断，这就自动实现了逻辑错误的提示了 不用一个请求一个请求的判断了，还是挺方便的 有了这些插件就可以这样初始化RxMoyaProvider `let provider :RxMoyaProvider&lt;ApiManager&gt; provider = RxMoyaProvider&lt;ApiManager&gt;( endpointClosure: endpointMapping, manager:defaultAlamofireManager(), plugins:[RequestLoadingPlugin(self.viewController,true), AccessTokenPlugin( self.viewController), NetworkLoggerPlugin(verbose: true), networkActivityPlugin,AuthPlugin(token: "暂时为空")] ` 关于Moya的用法先介绍到这里后续我会继续探究更加灵活全面的用法。 下边介绍下Then的语法棉花糖吧，看例子吧`_ = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: kScreenW, height: 50)).then({ (make) in make.text = "Then的简单用法超赞👍" make.font = .systemFont(ofSize: 20) make.textColor = .red make.textAlignment = .center self.view.addSubview(make) }) UserDefaults.standard.do { $0.set("devxoul", forKey: "username") $0.set("devxoul@gmail.com", forKey: "email") $0.synchronize() let tableView = UITableView().then { $0.backgroundColor = .clear $0.separatorStyle = .none $0.register(MyCell.self, forCellReuseIdentifier: "myCell") } } ` 如果布局这样还不简单那再看下边用Then和SnapKit一起使用的方式 `_ = UILabel().then({ (make) in make.text = "Then的简单用法超赞👍" make.font = .systemFont(ofSize: 20) make.textColor = .red make.textAlignment = .center self.view.addSubview(make) make.snp.makeConstraints({ (make) in make.top.left.right.equalTo(0) make.height.equalTo(50) }) }) ` 再不满意只能用Xib布局了…. 在Swift中用SDCycleScrollView轮播图SDCycleScrollView之前一直在OC中使用觉得很简单又熟悉了所以这次写的Demo依旧搬了过来，但是呢SDCycleScrollView里实现图片下载用的是SDWebImage，而Swift版本提供了Kingfisher那不可能都用了，因为也不想放弃SDCycleScrollView就不得已修改了里边图片下载的方法，在Swift项目里OC类直接调用Swift类是调用不到的，所以我就咨询了下找到一个合适办法，新建Swift里继承SDCycleScrollView然后用Kingfisher实现图片下载，方法比较简单就是给开发者提供一个参考方法 `import UIKit import SDCycleScrollView import Kingfisher class CustomSDCycleScrollView: SDCycleScrollView { //因为之前库里边用的是SDWebImageView 缓存的图片 现在 换了Swift版本的Kingfisher所以 无奈修改了原库的方法 重写了下 open override func imageView(_ imageView: UIImageView!, url: URL!) -&gt; UIImageView! { let imageView: UIImageView? = imageView imageView?.kf.setImage(with: url,placeholder:UIImage.init(named: "tab_5th_h")) return imageView } //重写oc代码 删除缓存 override class func clearImagesCache() { let cache = KingfisherManager.shared.cache // 获取硬盘缓存的大小 cache.calculateDiskCacheSize { (size) -&gt; () in print("磁盘缓存大小： \(size) bytes ") cache.clearDiskCache() } } } ` 用的时候直接使用CustomSDCycleScrollView即可 项目使用MJRefresh实现刷新给UIScrollView写了一个类别比较简单代码如下 `import UIKit import MJRefresh extension UIScrollView { func headerRefresh(block: @escaping () -&gt; ()) -&gt; (){ self.mj_header = MJRefreshNormalHeader.init(refreshingBlock: { block() }) } func footerRefresh(block: @escaping () -&gt; ()) -&gt; (){ self.mj_footer = MJRefreshBackNormalFooter(refreshingBlock: { block() }) } func endrefresh(){ self.mj_footer.endRefreshing() self.mj_header.endRefreshing() } } ` 用的时候更简单了 `weak var weakself = self//上拉刷新tableView.headerRefresh {weakself?.loadData()}//下拉加载tableView.footerRefresh{weakself?.loadData()}//结束刷新self.tableView.endrefresh()]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS跳转到AppStore常用方法]]></title>
    <url>%2F2018%2F03%2F19%2FJump2AppStoreMethod.html</url>
    <content type="text"><![CDATA[跳转到 AppStore 的常用方法，以下网址中将 id 后面的数字改为自己 App 的 id 即可。 1.通过Safari 输入网址跳转到 AppStore http://itunes.apple.com/us/app/id1234567890 2.App 内部通过代码直接跳转到 AppStore itms-apps://itunes.apple.com/cn/app/jie-zou-da-shi/id1234567890?mt=8 3.App 内部通过代码跳转到 AppStore 的评论区 itms-apps://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?type=Purple+Software&amp;id=1234567890 代码1234567891011121314151617/// appid替换成自己的appid let appid : String = "1234567890"/// URL替换成上面所提供的URLlet urlStirng = "itms-apps://itunes.apple.com/cn/app/jie-zou-da-shi/id\(appid)?mt=8" if #available(iOS 10, *) &#123; if let url = URL(string: urlStirng) , UIApplication.shared.canOpenURL(url) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125;&#125; else &#123; if let url = URL(string: urlStirng) , UIApplication.shared.canOpenURL(url) &#123; UIApplication.shared.openURL(url) &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AppStore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 iTunes 接口检查App版本更新]]></title>
    <url>%2F2018%2F01%2F16%2FiOS%2FAppStore%2F%E5%88%A9%E7%94%A8iTunes%E6%8E%A5%E5%8F%A3%E6%A3%80%E6%9F%A5App%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0.html</url>
    <content type="text"><![CDATA[iOS 想要检查 App 当前版本是否为最新，一般的方案大概都是服务器自己提供一个接口来获取 App 最新版本是多少，然后再做出相应提示是否需要更新，但是接口需要手动维护，应用要审核，还得等审核通过以后才能更新版本号，其实苹果提供了一个 iTunes 接口，能够查到 App 在 AppStore 上的状态信息，既省事又准确，下面记录一下具体实现方法。 接口信息URLiTunes 接口地址 有兴趣可以看一下，我们要用到的接口如下，xxx 处换成自己 App 的 AppId ，AppId 可以在 iTunes Connect 里面看到。 1http://itunes.apple.com/lookup?id=xxx Response JSON123456789101112131415&#123; "resultCount" : 1, "results" : [&#123; "artistId" : "开发者 ID", "artistName" : "开发者名称", "trackCensoredName" : "审查名称", "trackContentRating" : "评级", "trackId" : "应用程序 ID", "trackName" : "应用程序名称", "trackViewUrl" : "应用程序下载网址", "userRatingCount" : "用户评论数量", "userRatingCountForCurrentVersion" : "当前版本的用户评论数量", "version" : "版本号" &#125;]&#125; 实现方法下面是检查版本更新的具体实现方法，注意接口地址 xxx 处换成自己 App 的 AppId 开始请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/// 检查版本更新- (void)checkVersion &#123; NSString *url = @"http://itunes.apple.com/lookup?id=xxx"; [[AFHTTPSessionManager manager] POST:url parameters:nil progress:nil success:^(NSURLSessionDataTask *task, id responseObject) &#123; DLog(@"版本更新检查成功"); NSArray *results = responseObject[@"results"]; if (results &amp;&amp; results.count &gt; 0) &#123; NSDictionary *response = results.firstObject; NSString *currentVersion = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"]; // 软件的当前版本 NSString *lastestVersion = response[@"version"]; // AppStore 上软件的最新版本 if (currentVersion &amp;&amp; lastestVersion &amp;&amp; ![self isLastestVersion:currentVersion compare:lastestVersion]) &#123; // 给出提示是否前往 AppStore 更新 UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"提示" message:@"检测到有版本更新，是否前往 AppStore 更新版本。" preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@"前往" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) &#123; NSString *trackViewUrl = response[@"trackViewUrl"]; // AppStore 上软件的地址 if (trackViewUrl) &#123; NSURL *appStoreURL = [NSURL URLWithString:trackViewUrl]; if ([[UIApplication sharedApplication] canOpenURL:appStoreURL]) &#123; [[UIApplication sharedApplication] openURL:appStoreURL]; &#125; &#125; &#125;]]; [alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil]]; [self.window.rootViewController presentViewController:alert animated:YES completion:nil]; &#125; &#125; &#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123; DLog(@"版本更新检查失败"); &#125;];&#125; /// 判断是否最新版本号（大于或等于为最新）- (BOOL)isLastestVersion:(NSString *)currentVersion compare:(NSString *)lastestVersion &#123; if (currentVersion &amp;&amp; lastestVersion) &#123; // 拆分成数组 NSMutableArray *currentItems = [[currentVersion componentsSeparatedByString:@"."] mutableCopy]; NSMutableArray *lastestItems = [[lastestVersion componentsSeparatedByString:@"."] mutableCopy]; // 如果数量不一样补0 NSInteger currentCount = currentItems.count; NSInteger lastestCount = lastestItems.count; if (currentCount != lastestCount) &#123; NSInteger count = labs(currentCount - lastestCount); // 取绝对值 for (int i = 0; i &lt; count; ++i) &#123; if (currentCount &gt; lastestCount) &#123; [lastestItems addObject:@"0"]; &#125; else &#123; [currentItems addObject:@"0"]; &#125; &#125; &#125; // 依次比较 BOOL isLastest = YES; for (int i = 0; i &lt; currentItems.count; ++i) &#123; NSString *currentItem = currentItems[i]; NSString *lastestItem = lastestItems[i]; if (currentItem.integerValue != lastestItem.integerValue) &#123; isLastest = currentItem.integerValue &gt; lastestItem.integerValue; break; &#125; &#125; return isLastest; &#125; return NO;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>版本更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift-重写与重载的使用和比较]]></title>
    <url>%2F2017%2F10%2F03%2FiOS%2FSwift%2FSwift-%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%AF%94%E8%BE%83.html</url>
    <content type="text"><![CDATA[1.重载: 函数名相同，参数名;参数类型;参数个数不同 重载函数并不仅仅局限于构造函数 函数重载是面相对象程序设计语言的重要标志 OC 不支持函数重载，OC 的替代方式是 withXXX… 2. 重写： 也叫覆盖，指在子类中定义一个与父类中方法同名同参数列表的方法。 重写是子类的方法覆盖父类的方法，要求方法名和参数都相同 因为子类会继承父类的方法，而重写就是将从父类继承过来的方法重新定义一次，重新填写方法中的代码。 重写必须继承，重载不用 假设有一个Person类,用于 name 和 age 两个属性,我们分别用重写和重载方法为其添加属性 创建Person类12345678910111213class Person: NSObject &#123; var name: String // 姓名 var age: Int // 年龄 // 构造函数 init(name: String,age: Int) &#123; self.name = name self.age = age // 必须在 super.init() 之前 初始化对象 super.init() &#125;&#125; 通过重写方法为其添加 “lesson” 属性1234567891011121314151617class Student: Person &#123; var lesson: String /// 重写 /// /// - Parameters: /// - name: 姓名 /// - age: 年龄 override init(name: String, age: Int) &#123; lesson = "Python" // 必须放在super.init()之前 super.init(name: name, age: age) &#125;&#125; 123/// 重写实例化的对象let s = Student(name: "Joyce", age: 18)print(s.lesson) // Python 通过重载方法为其添加 “lesson” 属性123456789101112131415161718class Student: Person &#123; var lesson: String /// 重载 /// /// - Parameters: /// - name: 姓名 /// - age: 年龄 /// - lesson: 课程 init(name: String, age: Int, lesson:String) &#123; self.lesson = lesson super.init(name: name, age: age) &#125;&#125; 123/// 重载实例化的对象let s1 = Student(name: "Yang", age: 24, lesson: "iOS")print(s1.lesson) // iOS 总结: 通过重载,可以快速为方法添加新的属性,属性可以通过外部传入 重写,只能在方法内部设置属性,外部无法直观看到类的参数列表]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-类和结构体(class&struct)]]></title>
    <url>%2F2017%2F10%2F02%2Fswift-class%26struct.html</url>
    <content type="text"><![CDATA[较传统的OC语言，swift使用了更多的结构体,在 swift 中，所有的基本类型,都是结构体类型 整数（Integer） 浮点数（floating-point） 布尔值（Boolean） 字符串（string) 数组（array) 字典（dictionary） 在比较类和结构体之间的区别之前，先了解两个概念，引用类型和值类型：引用类型 引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝 值类型 它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制 类和结构体对比本质区别： 类是引用类型，实例是通过引用传递 结构体是值类型，实例是通过值传递 swift 中类和结构体有很多共同点 定义属性用于存储值 定义方法用于提供功能 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 与结构体相比，类还有如下的附加功能 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 结构体和类的定义语法结构体定义语法123struct SomeStructure &#123; // 在这里定义结构体&#125; 所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性 类定义语法 （一） 不继承NSObject的类，叫做基类 123class SomeClass &#123; // 在这里定义类&#125; 类定义语法 （二） 这种类继承自NSObject,可以使用OC中的 NSObject 的特性 eg:KVO,runtime 123class SomeClass: NSObject &#123; // 在这里定义类&#125; 类和结构体使用注意类是引用类型，其属性如果是可变类型，可以直接修改，修改后类型不变结构体是值类型，初始化完成后，一般情况下，不允许修改其属性；如果修改其属性，会生成一个新的结构体；如果想不改变结构体的类型，需要定义一个mutating修饰的方法，专门用来修改其属性 写时复制 (copy-on-write)swift用了大量的结构体，每次修改都是复制一份，是不是很浪费内存？ 答：在 swift 标准库中，像是 Array，Dictionary 和 Set 这样的集合类型是通过一种叫做写时复制 (copy-on-write) 的技术实现的，该技术优化了这一问题，让结构体在核合适的时候才进行复制。 类和结构体的选择当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值； 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用； 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用； 该数据结构不需要去继承另一个既有类型的属性或者行为。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-切片使用详解]]></title>
    <url>%2F2017%2F05%2F20%2FPython%2Fbasics%2FPython-%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[切片含义 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 切片使用 切片的语法: [起始:结束:步长] 123name = 'abcdef'print(name[0:3]) # 取 下标0~2 的字符 1. 截取所有字符串123456789name = 'abcdef'name[:] ``` #### 2. 截取最后一个字符串 ```Pythonname = 'abcdef'name[-1] 3. 反转字符串：12name = 'abcdef'name[-1:0:-1] tips步进数值意味着切片的方向及长度 - 1 倒着切片 + 1 默认，正常切片 注意：选取的区间属于左闭右开型，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。*]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-string使用]]></title>
    <url>%2F2017%2F05%2F14%2Fpythonstring.html</url>
    <content type="text"><![CDATA[string 常见操作&#39;mystr = &#39;hello nilhy , This is Python demo&#39; find检测 str 是否包含在 mystr 中，如果是返回开始的索引值，否则返回 -1 12# 记住,返回的是所在位置索引值,没找到就返回-1mystr.find(str, start=0, end=len(mystr)) index跟find()方法一样，只不过如果str不在 mystr中会报一个异常. 12# 如果没有找到,会抛出异常'substring not found'mystr.index(str, start=0, end=len(mystr)) count返回 str在start和end之间 在 mystr里面出现的次数 1mystr.count(str, start=0, end=len(mystr)) replace把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次. 12# 记住这里替换之后会返回一个新的字符串mystr.replace(str1, str2, mystr.count(str1)) split以 str 为分隔符切片 mystr，如果 maxsplit有指定值，则仅分隔 maxsplit 个子字符串 12# 按照空格字符串拆分,参数2为最大拆分数mystr.split(str=" ", 2) capitalize把字符串的第一个字符大写 1mystr.capitalize() title把字符串的每个单词首字母大写 123&gt;&gt;&gt; a = "hello jianshu"&gt;&gt;&gt; a.title()&gt;&gt;&gt; 'Hello Jianshu' startswith检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False 1mystr.startswith(obj) endswith检查字符串是否以obj结束，如果是返回True,否则返回 False. 1mystr.endswith(obj) lower转换 mystr 中所有大写字符为小写 1mystr.lower() upper转换 mystr 中的小写字母为大写 1mystr.upper() ljust返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 1mystr.ljust(width) rjust返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 1mystr.rjust(width) center返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 1mystr.center(width) lstrip删除 mystr 左边的空白字符 1mystr.lstrip() rstrip删除 mystr 字符串末尾的空白字符 1mystr.rstrip() strip删除mystr字符串两端的空白字符 1234# 只是去除两端字符串,如果 'jian shu', 中间存在空格,则不去除中间的&gt;&gt;&gt; a = "\n\t jianshu \t\n"&gt;&gt;&gt; a.strip()&gt;&gt;&gt; 'jianshu' rfind类似于 find()函数，不过是从右边开始查找. 1mystr.rfind(str, start=0,end=len(mystr) ) rindex类似于 index()，不过是从右边开始. 1mystr.rindex( str, start=0,end=len(mystr)) partition(分区, 分成3段)把mystr以str分割成三部分,str前，str 12# 返回一个元祖, 参数是按照那个字符串去拆分mystr.partition(str) rpartition类似于 partition()函数,不过是从右边开始. 12# 从右到左,分三段mystr.rpartition(str) splitlines按照行分隔，返回一个包含各行作为元素的列表 12# 分割的字符串,按照\n 分割mystr.splitlines() isalpha如果 mystr 所有字符都是字母 则返回 True,否则返回 False 12# 必须为存字符, 空格都属于其他字符,mystr.isalpha() isdigit如果 mystr 只包含数字则返回 True 否则返回 False. 12# 必须为纯数字, 空格都属于其他字符,mystr.isdigit() isalnum如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False 1mystr.isalnum() isspace如果 mystr 中只能包含空格，则返回 True，否则返回 False. 1mystr.isspace() joinmystr 中每个字符后面插入str,构造出一个新的字符串 123456# 用法 : mystr.join(str)&gt;&gt;&gt; strs = ['my','name','is', 'hai']&gt;&gt;&gt; strSpace = ' '&gt;&gt;&gt; strSpace.join(strs)# 以下是输出结果&gt;&gt;&gt; 'my name is hai' 问题:给定一个字符串aStr，返回使用空格或者’\t’分割后的倒数第二个子串 12345678testStr = 'haha nihao a \t heihei \t woshi nide \t hao \nnnn' # 即可以去除以上字符串中的所有转义和空格符号 # 1. 去除\t \n 空格strList = testStr.strip()# 2. 得到新的字符串,拼接起来newStr = ''.join(strList)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C-不定参详解]]></title>
    <url>%2F2017%2F02%2F11%2FiOS%2FObjective-C%2FObjective-C-%E4%B8%8D%E5%AE%9A%E5%8F%82%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[简单介绍一下这个,下面会有详细的用法和解释、 大致含义 : 一个可变参数函数是指一个函数拥有不定的参数，即为一个函数可接收多个参数。有时会遇到一些算术问题需要用到，比如是计算传入参数的总和，字符串的连接或是其它操作过程，在 Objective-C 里也经常使用，最经典的就是 NSLog（ C 为 printf ） ，它可以指定格式的输出，格式化输出的内容. 当然,不定参数,你也可以使用数组代替。废话不多说,直接上代码开干了….12345678910111213141516- (void)print:(NSString *)firstArg, ... NS_REQUIRES_NIL_TERMINATION &#123; if(firstArg) &#123; // 1.定义一个指向个数可变的参数列表指针 va_list args; // 2.用于存放取出的参数 NSString *arg; // 3.初始化变量刚定义的va_list变量，这个宏的第二个参数是第一个可变参数的前一个参数，是一个固定的参数 va_start(args, firstArg); // 4.遍历全部参数 va_arg返回可变的参数(a_arg的第二个参数是你要返回的参数的类型) while ((arg = va_arg(args, NSString *))) &#123; NSLog(@"%@", arg); &#125; // 清空参数列表，并置参数指针args无效 va_end(args); &#125;&#125; 下面就是来解释各个方法和参数的含义 va_list : 用来保存宏 va_start 、va_arg 和 va_end所需信息的一种类型。为了访问变长参数列表中的参数，必须声明 va_list 类型的一个对象 va_start : 访问变长参数列表中的参数之前使用的宏，它初始化用va_list声明的对象，初始化结果供宏va_arg和va_end使用 va_arg : 展开成一个表达式的宏，该表达式具有变长参数列表中下一个参数的值和类型。每次调用 va_arg 都会修改，用 va_list 声明的对象从而使该对象指向参数列表中的下一个参数 va_end : 该宏使程序能够从变长参数列表用宏 va_start 引用的函数中正常返回 NS_REQUIRES_NIL_TERMINATION : 是一个宏，用于编译时非nil结尾的检查 使用注意 在可变参数里，所有参数均用逗号隔开 参数结尾必须加上nil，表示参数结束]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C-事件处理与如何获得最佳点击的View]]></title>
    <url>%2F2016%2F11%2F14%2FiOS%2FObjective-C%2FObjective-C-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%8E%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E6%9C%80%E4%BD%B3%E7%82%B9%E5%87%BB%E7%9A%84View.html</url>
    <content type="text"><![CDATA[事件的产生与传递事件是如何产生与传递的? 当发生触摸事件的后,系统会将该事件加入到一个由UIApplication管理的时间队列中,UIApplication会从事件队列中取出最前面的事件,并将这个事件分发下去,以便处理,主窗口即Window 会在视图层次中找到一个合适的视图来处理触摸事件 触摸事件的传递是从父控件传递给子控件的,如果父控件不能接受事件,则里面的所有子控件也不能接收事件 当一个控件不能接受事件时,一般有几种情况 不接收用户交互:userInteractionEnabled = NO 当一个控件隐藏时:Hidden = YES 当一个控件为透明时 事件的响应 用户点击屏幕产生的一个触摸事件,经过一系列的传递过程后,会找到一个最适合的视图来处理事件.找到最合适的视图控件后,就会调用控件的touches方法来作具体的事件处理.touches的默认做法是将事件顺着响应者链条向上传递,将事件交给上一个响应者处理 什么是响应者链条? 由多个响应者对象连接起来的链条 什么是响应者对象? 继承了UIResponder的对象 如何去寻找上一个响应者 1.如果当前的View是控制器的View,那么控制器就是上一个响应者 2.如果当前的View不是控制器的View,那么他的父控件就是上一个响应者 3.在视图层次结构的最顶级视图,如果也不能处理收到的事件或消息,则其将事件或消息传递给window对象进行处理 4.如果window对象也不处理，则其将事件或消息传递给UIApplication对象 5.如果UIApplication也不能处理该事件或消息，则将其丢弃 系统是如何寻找最合适的View* 1.先判断自己是否能接收触摸事件 2.再判断触摸的当前点在不在自己身上 3.如果在自己身上,它会从后往前遍历子控件,遍历出每一个控件后,重启前两步 4.如果没有符合条件的子控件,那么自身就是最合适的View 在寻找最合适View的过程中,系统会调用2个方法123456789101112131415// 作用:寻找最适合的View// 什么时候调用:当事件传递给当前View时就会调用这个方法- (UIView *) hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; UIView *fitView = [super hitTest:point withEvent:event]; NSLog(@"%@",fitView); return fitView;&#125;// 作用:判断触摸点在不在当前的View上.// 什么时候调用:在hitTest方法当中会自动调用这个方法.// 注意:point必须得要跟当前View同一个坐标系.- (BOOL) pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; return YES;&#125; 那么hitTest: withEvent:方法底层是如何实现的呢?12345678910111213141516171819202122// 判断自己能否接收事件if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) &#123; return nil;&#125;// 触摸点在不在自己身上if ([self pointInside:point withEvent:event] == NO) &#123; return nil;&#125;// 从后往前遍历自己的子控件(重复前面的两个步骤)int count = (int)self.subviews.count;for (int i = count -1; i &gt;= 0; i--) &#123; UIView *childV = self.subviews[i]; // point必须得要跟childV相同的坐标系. // 把point转换childV坐标系上面的点 CGPoint childP = [self convertPoint:point toView:childV]; UIView *fitView = [childV hitTest:childP withEvent:event]; if (fitView) &#123; return fitView; &#125; &#125;// 如果没有符合条件的子控件，那么就自己最适合处理return self; 在开发中或多或少会需要一些特殊的点击,这里有2个小例子供大家参考 一个按钮被一个半透明的View部分遮挡,需要点击到按钮的时候,按钮始终响应 一个View超出了父视图的范围,需要点击超出范围的View也有响应 123456789101112- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; //当触摸点在按钮上的时候,才让按钮去响应事件. //把当前点转换成按钮坐标系上的点. CGPoint btnP = [self convertPoint:point toView:self.btn]; if ( [self.btn pointInside:btnP withEvent:event]) &#123; return self.btn; &#125;else&#123; return [super hitTest:point withEvent:event]; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
</search>
